{
  "author": {
    "name": "Tomas Brambora",
    "email": "tomas@salsitasoft.com"
  },
  "name": "restq",
  "description": "Declarative way of getting data from RESTful APIs.",
  "version": "0.10.3",
  "keywords": [
    "rest",
    "restful",
    "query",
    "web",
    "request",
    "api"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/salsita/RestQ"
  },
  "scripts": {
    "test": "mocha --compilers coffee:coffee-script"
  },
  "main": "restQuery.coffee",
  "dependencies": {
    "q": "~0.9",
    "request": "2.30",
    "underscore": "~1.3.3",
    "underscore.string": "~2.2.0rc"
  },
  "devDependencies": {
    "mocha": "~1.16",
    "nock": "~0.27",
    "should": "~0.6.3",
    "chai": "~1.8",
    "chai-as-promised": "~3.2.0",
    "coffee-script": "~1.6.3"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "~0.10"
  },
  "readme": "#RestQ\nRestQ is a little helper module that allows you to follow RESTful API links in a more declarative style.\n\n<a href=\"https://nodei.co/npm/restq/\"><img src=\"https://nodei.co/npm/restq.png\"></a>\n\n[![Build Status](https://secure.travis-ci.org/salsita/RestQ.png)](http://travis-ci.org/salsita/restq)\n\n### Why is that cool?\n\nOK, let's say we have a server that exposes a `/posts/42.json` resource, which\ncontains an `{\"author\": {\"person_id\": \"foo\"}}` link to a `/people/<person_id>.json` \nresource. And we want to get the post author's email.\n\nOne way would be to do something like this:\n\n    request.get('http://server.com/posts/42.json, (err, res, body) ->\n      if err or res.statusCode isnt 200\n        # Handle errors here...\n      request.get('http://server.com/people/#{body.author.id}.json), (err, res, body) ->\n        if err or res.statusCode isnt 200\n          # Handle errors here.\n        email = body['email-address']\n        \nNow that's not too terrible, but it's not awesome either. \nThe nesting is kind of annoying (imagine what happens when there are more levels...) \nand the code is just not as readable as it could be.\n\n#### So how does RestQ help?\nWell, with RestQ, we can call:\n\n    emailPromise = RQ.from('http://server.com/posts/42.json')\n      .via('/people/{author.id}.json')\n      .get('email-address')\n      \nAnd we get a 'thenable' (promise) for the post author's email stored in `emailPromise`.\n\nNow when we need the actual email address, we do:\n   \n    p.then (email) -> ... email is here ...\n\net voila!\n\n\n## Installation\n    npm install restq\n    \n## Running tests\n    npm test\n\n### Kudos to\n[Underscore](https://github.com/documentcloud/underscore/),\n [Underscore.string](https://github.com/epeli/underscore.string),\n [Q](https://github.com/kriskowal/q),\n [Request](https://github.com/mikeal/request) \n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/salsita/RestQ/issues"
  },
  "homepage": "https://github.com/salsita/RestQ",
  "_id": "restq@0.10.3",
  "dist": {
    "shasum": "1735a54b55709ec22d29a964ccb10bbac7f81bb1",
    "tarball": "http://registry.npmjs.org/restq/-/restq-0.10.3.tgz"
  },
  "_from": "restq@*",
  "_npmVersion": "1.3.21",
  "_npmUser": {
    "name": "tomas.brambora",
    "email": "tomas.brambora@gmail.com"
  },
  "maintainers": [
    {
      "name": "tomas.brambora",
      "email": "tomas.brambora@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "1735a54b55709ec22d29a964ccb10bbac7f81bb1",
  "_resolved": "https://registry.npmjs.org/restq/-/restq-0.10.3.tgz"
}
